<html>
<head>
  <title>苏同的模板plus</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/603450 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="4617"/>
<h1>苏同的模板plus</h1>

<div>
<span><div><div><span style="font-size: 36pt;">杜教筛：</span></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/f4448c8ba80acb66c516f1ac1958f109-105225" width="1778"></img></div><div><span style="font-size: 36pt;">Polya定理：</span>（南昌的那个题要补一下）</div><div>可以简单的理解为所有置换下不动点的平均值（暴力做法：枚举每种置换，计算当前置换下，有多少方案置换前后不会变（即不动点的个数），再将所有置换的不动点个数取个平均值即可）</div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/0e86625b74f206d0b298504ae13e632d-127661" width="1186"></img></div><div>环上n个珠子（循环同构），三种颜色，第一种颜色出现的次数不能超过k次，且相邻不能相等，求方案数。</div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/4290beda810af2bab0978433d06e24fb-469855" width="908"></img></div><div><br clear="none"/></div><div><span style="font-size: 36pt;">利用矩阵，代数优化DP方程：</span></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/c90d4ecb90a99397c36233965dec2c75-61806" width="527"></img></div><div><span style="font-size: 36pt;">min25筛：</span></div><div>//min25 f(p^k) = p^2k-p^k 需要拆成每一项都是完全积性函数</div><div>#include&lt;bits/stdc++.h&gt;</div><div>using namespace std;</div><div>typedef long long ll;</div><div>const ll mod = 1e9+7;</div><div>const int maxn = 1e6+5;</div><div>int pri[maxn],num;bool vis[maxn];</div><div>const int fn=2;//项数</div><div>int sp[fn][maxn];</div><div>ll n,sqr,tot,g[fn][maxn],w[maxn],ind1[maxn],ind2[maxn];</div><div>//修改</div><div>int fu[fn]={1,-1};//符号</div><div><br clear="none"/></div><div>int f(int fid,int p,int e,ll pe){//f(x)</div><div>    if(fid==0){</div><div>        pe%=mod;</div><div>        return pe*pe%mod;</div><div>    }</div><div>    if(fid==1){</div><div>        return pe%mod;</div><div>    }</div><div>}</div><div><br clear="none"/></div><div>int sigmaf(int fid,ll n) //对于2到n，假设其是素数的和</div><div>{</div><div>    n%=mod;</div><div>    int inv2=500000004,inv6=166666668;</div><div>    if(fid==0){</div><div>        return  n*(n+1)%mod*(2*n+1)%mod*inv6%mod-1;</div><div>    }</div><div>    if(fid==1){</div><div>        return (n*(n+1)%mod*inv2-1)%mod;</div><div>    }</div><div>}</div><div><br clear="none"/></div><div>//end</div><div>void init(){</div><div>    int n=maxn-5;</div><div>    vis[1]=1;</div><div>    for(int i=1;i&lt;=n;i++){</div><div>        if(!vis[i]){</div><div>            pri[++num]=i;</div><div>            for(int j=0;j&lt;fn;j++) sp[j][num]=(sp[j][num-1]+f(j,i,1,i))%mod;</div><div>        }</div><div>        for(int j=1;j&lt;=num&amp;&amp;1ll*pri[j]*i&lt;=n;j++){</div><div>            vis[i*pri[j]]=1;</div><div>            if(i%pri[j]==0) break;</div><div>        }</div><div>    }</div><div>}</div><div><br clear="none"/></div><div>void G(){</div><div>    for(ll l=1,r;l&lt;=n;l=r+1){</div><div>        r=n/(n/l);</div><div>        w[++tot]=n/l;</div><div>        for(int j=0;j&lt;fn;j++){</div><div>            g[j][tot]=sigmaf(j,w[tot]);</div><div>        }</div><div>        if(n/l&lt;=sqr) ind1[n/l]=tot;</div><div>        else ind2[n/(n/l)]=tot;</div><div>    }</div><div>    for(int i=1;i&lt;=num;i++){</div><div>        for(int j=1;j&lt;=tot&amp;&amp;1ll*pri[i]*pri[i]&lt;=w[j];j++){</div><div>            ll k=w[j]/pri[i]&lt;=sqr?ind1[w[j]/pri[i]]:ind2[n/(w[j]/pri[i])];</div><div>            for(int l=0;l&lt;fn;l++){</div><div>                g[l][j]=(g[l][j]+mod-f(l,pri[i],1,pri[i])*(g[l][k]-sp[l][i-1]+mod)%mod)%mod;</div><div>            }</div><div>        }</div><div>    }</div><div>}</div><div><br clear="none"/></div><div>ll S(ll x,ll y=0){</div><div>    if(pri[y]&gt;=x) return 0;</div><div>    ll k=x&lt;=sqr?ind1[x]:ind2[n/x];</div><div>    ll ans=0;</div><div>    for(int i=0;i&lt;fn;i++){</div><div>        (ans+=mod+fu[i]*(g[i][k]-sp[i][y]))%=mod;</div><div>    }</div><div>    for(int i=y+1;i&lt;=num&amp;&amp;1ll*pri[i]*pri[i]&lt;=x;i++){</div><div>        ll pe=pri[i];</div><div>        for(int e=1;pe&lt;=x;e++,pe*=pri[i]){</div><div>            ll xx=0;</div><div>            for(int j=0;j&lt;fn;j++){</div><div>                (xx+=mod+fu[j]*f(j,pri[i],e,pe))%=mod;</div><div>            }</div><div>            ans=(ans+xx*(S(x/pe,i)%mod+(e!=1))%mod)%mod;</div><div>        }</div><div>    }</div><div>    return ans;</div><div>}</div><div><br clear="none"/></div><div>int main(){</div><div>    init();</div><div>    cin&gt;&gt;n;</div><div>    sqr=sqrt(n);</div><div>    G();</div><div>    cout&lt;&lt;S(n)+1&lt;&lt;endl;</div><div>}</div><div><span style="font-size: 36pt;">竞赛图：</span></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/ea3fe28252fbc6a20682607ba089737c-77706" width="706"></img></div><div><span style="font-size: 36pt;">线段树：</span></div><div>#include&lt;bits/stdc++.h&gt;</div><div>using namespace std;</div><div>typedef long long ll;</div><div>const int N = 1e5+5;</div><div><br clear="none"/></div><div>int n,a[N];</div><div><br clear="none"/></div><div>struct ST{</div><div>    int tot;</div><div>    int ls[N&lt;&lt;1],rs[N&lt;&lt;1];</div><div>    ll mx[N&lt;&lt;1],tag[N&lt;&lt;1],s[N&lt;&lt;1];</div><div><br clear="none"/></div><div>    void up(int x){</div><div>        mx[x]=max(mx[ls[x]],mx[rs[x]]);</div><div>        s[x]=s[ls[x]]+s[rs[x]];</div><div>    }</div><div><br clear="none"/></div><div>    void down(int x,int l,int r){</div><div>        if(!tag[x])return;</div><div>        int mid=l+r&gt;&gt;1;</div><div>        if(ls[x]){</div><div>            tag[ls[x]]+=tag[x];</div><div>            mx[ls[x]]+=tag[x];</div><div>            s[ls[x]]+=tag[x]*(mid-l+1);</div><div>        }</div><div>        if(rs[x]){</div><div>            tag[rs[x]]+=tag[x];</div><div>            mx[rs[x]]+=tag[x];</div><div>            s[rs[x]]+=tag[x]*(r-mid);</div><div>        }</div><div>        tag[x]=0;</div><div>    }</div><div><br clear="none"/></div><div>    int build(int l,int r){</div><div>        int x=++tot;</div><div>        if(l==r){</div><div>            mx[x]=s[x]=a[l];</div><div>            return x;</div><div>        }</div><div>        int mid=l+r&gt;&gt;1;</div><div>        ls[x]=build(l,mid);</div><div>        rs[x]=build(mid+1,r);</div><div>        up(x);</div><div>        return x;</div><div>    }</div><div><br clear="none"/></div><div>    void change(int x,int l,int r,int L,int R,ll d){</div><div>        if(L&lt;=l&amp;&amp;r&lt;=R){</div><div>            tag[x]+=d;</div><div>            mx[x]+=d;</div><div>            s[x]+=d*(r-l+1);</div><div>            return;</div><div>        }</div><div>        down(x,l,r);</div><div>        int mid=l+r&gt;&gt;1;</div><div>        if(L&lt;=mid)change(ls[x],l,mid,L,R,d);</div><div>        if(R&gt;mid)change(rs[x],mid+1,r,L,R,d);</div><div>        up(x);</div><div>    }</div><div><br clear="none"/></div><div>    ll sum(int x,int l,int r,int L,int R){</div><div>        if(L&lt;=l&amp;&amp;r&lt;=R){</div><div>            return s[x];</div><div>        }</div><div>        down(x,l,r);</div><div>        int mid=l+r&gt;&gt;1;</div><div>        ll ret=0;</div><div>        if(L&lt;=mid)ret+=sum(ls[x],l,mid,L,R);</div><div>        if(R&gt;mid)ret+=sum(rs[x],mid+1,r,L,R);</div><div>        up(x);</div><div>        return ret;</div><div>    }</div><div><br clear="none"/></div><div>    void init(){</div><div>        for(int i=1;i&lt;=tot;++i){</div><div>            tag[i]=mx[i]=s[i]=ls[i]=rs[i]=0;</div><div>        }</div><div>        tot=0;</div><div>        int root=build(1,n);</div><div>    }</div><div>}T;</div><div><span style="font-size: 36pt;">斯特林数：</span></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/6fdd3ec20392a8a9c688c7bac1422bf0-113431" width="1446"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/26a7e9cada6564e20f15c2096437790f-45682" width="1454"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/2cbda104e9d1fa3b508268fff5bdb54b-31843" width="1447"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/78a72504ea9cf81b279892e8f66318ab-28999" width="1439"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/f7d20c27eafa328368f4e75783a18d25-543040" width="1452"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/f265f6fa03a1b57acebac8eef9699798-34183" width="597"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/72935428af2292d6065afa72f2e11c14-6823" width="745"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/24e3ec92f7e4837418f475d4e1f5a700-120975" width="1446"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/64ff02ce5b4c19dcc701b97aa199492f-171679" width="1456"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/f307aa52955393002a7a1480f9454331-104216" width="1456"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/53c1dc96f45e9881b0f9a66561130b99-227290" width="1447"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/f2690c993af7741b6c6135c44e693dc5-344639" width="1454"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/da5e72b8ac52528c013987714dc766f3-36629" width="569"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/257be6487fea263f4c8a0029c7839432-63675" width="881"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/239426293bfa55b9126b8e3b0ef53964-54204" width="849"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/7308294418916c9ee15d9a09e7ca07a1-130938" width="897"></img></div><div><span style="font-size: 36pt;">贝尔数：</span></div><div><span style="font-size: unset; color: unset; font-family: unset;"> </span><img src="https://app.yinxiang.com/FileSharing.action?hash=1/dbe9749fc092af00bd221adf784f9f1b-53899" width="908"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/ba86def86d5539372697e13066dba1bc-59104" width="826"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/03814a03cc2f628021c9d40da24a9052-39822" width="974"></img></div><div><span style="font-size: 36pt;">斐波那契数列：</span><span style="font-size: unset; color: unset; font-family: unset;"> </span></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/13464ddfc2078c9edd7626c4d32d9b8e-27067" width="872"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/31c97efb56d4ab1f5d83c2eb54eec090-75925" width="845"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/8648758ff7e7682a1bc298b5bfccd571-82532" width="743"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/4d1d777cbbe2c0ad5352f4e0d195fcdb-16426" width="743"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/967b1a196105b56ef7d679cefbd28226-57043" width="699"></img></div><div><span style="font-size: 36pt;">组合数：</span><img src="https://app.yinxiang.com/FileSharing.action?hash=1/b4f4582f1eebef38ba33a0d5881253c3-74029" style="color: unset; font-family: unset; font-size: unset;" width="910"></img></div><div><span style="font-size: 36pt;">卡特兰数：</span></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/84b5e8d20139cfdf20bc55b801584206-158746" width="816"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/e7ba3ad74851692fbef477ca26bdcda9-7524" width="439"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/bb9d28ec3132cec48b9d82fac8d356fe-39911" width="799"></img></div><div><span style="font-size: 36pt;">错排数：</span></div><div><span style="font-size: 36pt;"><img src="https://app.yinxiang.com/FileSharing.action?hash=1/caf6a6cd7eefb9aaff6ff2a237863a44-58243" width="843"></img></span></div><div><span style="font-size: 36pt;">Schroder数：</span></div><div><span style="font-size: 36pt;"><img src="https://app.yinxiang.com/FileSharing.action?hash=1/311c77541b137b525b25cb6e06cc02cb-68902" width="786"></img></span></div><div><span style="font-size: 36pt;"><img src="https://app.yinxiang.com/FileSharing.action?hash=1/7feef94bde88c206f92e82ba1f3fee08-109148" width="799"></img></span></div><div><span style="font-size: 36pt;"><img src="https://app.yinxiang.com/FileSharing.action?hash=1/cea105e20968305a0df78d5e6fb5c658-62508" width="763"></img></span></div><div><span style="font-size: 36pt;">欧拉数：</span></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/e82641a61c3c441db43f12694ff8c4b3-40098" width="759"></img><img src="https://app.yinxiang.com/FileSharing.action?hash=1/2e85ea8f9bc07511423cd0f09aff655d-19661" style="color: unset; font-size: unset;" width="753"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/5d9bce4381ddaf98c58a028725c2224e-60727" width="812"></img></div><div><span style="font-size: 36pt;">旋转矩阵：</span><span style="font-size: unset; color: unset; font-family: unset;">   </span></div><div><span style="font-size: unset; color: unset; font-family: unset;">（顺时针）</span></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/39afd2c1c8adf0ef7ea8cd9f5e79ab8e-145438" width="1205"></img></div><div><img src="https://app.yinxiang.com/FileSharing.action?hash=1/fc2b7b8c8b46180bcff16a8e8bc4d758-152355" width="1191"></img></div><div><span style="font-size: 36pt;">对顶栈：</span></div><div>（可计算前缀和的尺取可以通过对顶栈的方式避免左端点右移产生的删除操作）</div><div>cy1999:</div><div>你不是尺取么，<span style="font-size: unset; color: unset; font-family: unset;">左端点是1，</span><span style="font-size: unset; color: unset; font-family: unset;">此时右端移动到了r。</span><span style="font-size: unset; color: unset; font-family: unset;">你搞一个r到1的矩阵乘积后缀积，</span><span style="font-size: unset; color: unset; font-family: unset;">相当于把r看作起点，向前维护后缀积，向后维护前缀积，然后</span><span style="font-size: unset; color: unset; font-family: unset;">左端点在[1,r]的就可以不删除尺取了。</span> 当左端点移动到了r，此时对应的右端点为next_r，那么再将next_r作为新的起点<span style="font-size: unset; color: unset; font-family: unset;">，向前维护后缀积（向前只用到r+1即可），向后维护前缀积，以此类推。复杂度为O(n)。</span></div><div><span style="font-size: unset; color: unset; font-family: unset;"><br/></span></div><h1><span style="font-size: 36pt;">环形不相邻组合：</span></h1><div>分析：</div><div>①当n&lt;2r时，取法为0种</div><div>例如4个球围一圈，选互不相邻的3个球，找不到这样的组合</div><div>①当n&gt;=2r时，取法为C(n-r,r)n/(n-r)种</div><div>首先对球进行编号，1号~n号，对于任何可能的组合，都只有两种情况：包含1号球的和不包含1号球的。</div><div><br/></div><div>包含1号球：首先选出1号球，然后需要从3号球~n-1号球取出r-1个互不相邻的球，根据上面那道题的结论，我们可以得到组合数为C(n-3-(r-1)+1,r-1)=C(n-r-1,r-1)；</div><div><br/></div><div>不包含1号球：我们需要从2号球~n号球取出r个互不相邻的球，其组合数为C(n-1-r+1,r)=C(n-r,r)</div><div><br/></div><div>综上，总数为C(n-r-1,r-1)+C(n-r,r)=C(n-r,r)n/(n-r)</div><div><br clear="none"/></div></div></span>
</div></body></html> 